package com.pg.sparc.market.jp.service.impl;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.quartz.JobExecutionException;

import com.pg.sparc.common.ddp.model.DataLoadBaseConfiguation;
import com.pg.sparc.entity.LoyalitySynchUpdateMetaData;
import com.pg.sparc.entity.TransactionEntity;
import com.pg.sparc.repository.CounterRepository;
import com.pg.sparc.repository.LoyalitySynchUpdateMetaDataRepository;
import com.pg.sparc.repository.TransactionRepository;

@ExtendWith(MockitoExtension.class)
class DDPLoyalitySynchUpdateSrviceImplTest {

    @Mock
    private LoyalitySynchUpdateMetaDataRepository loyalitySynchUpdateMetaDataRepository;

    @Mock
    private TransactionRepository transactionRepository;

    @Mock
    private CounterRepository counterRepository;

    @InjectMocks
    private DDPLoyalitySynchUpdateSrviceImpl ddpLoyalitySynchUpdateSrvice;

    private DataLoadBaseConfiguation conf;

    @BeforeEach
    void setUp() {
        conf = new DataLoadBaseConfiguation();
        conf.setExternalParams(Map.of(
            "job-name", "TestJob",
            "pilot-counter", "C1,C2",
            "market-code", "M1"
        ));
    }

    @Test
    void testLoyalitySynchUpdateProcess_Success() throws JobExecutionException {
        List<String> pilotCounterList = Arrays.asList("C1", "C2");
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        LoyalitySynchUpdateMetaData metaData = new LoyalitySynchUpdateMetaData();
        metaData.setLastRunTime(ZonedDateTime.now().minusDays(1));
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(counterRepository.findIdsByCounterCodes(pilotCounterList)).thenReturn(realCounterIds);
        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc("TestJob")).thenReturn(metaData);
        when(transactionRepository.findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(
                "M1", realCounterIds, metaData.getLastRunTime())).thenReturn(transactionEntities);

        ddpLoyalitySynchUpdateSrvice.loyalitySynchUpdateProcess(conf);

        verify(counterRepository).findIdsByCounterCodes(pilotCounterList);
        verify(loyalitySynchUpdateMetaDataRepository).findTopByJobNameOrderByLastRunTimeDesc("TestJob");
        verify(transactionRepository).findByMarketCodeAndCounterNotInAndLastModifiedDateAfter("M1", realCounterIds, metaData.getLastRunTime());
    }

    @Test
    void testLoyalitySynchUpdateProcess_FirstRun() throws JobExecutionException {
        List<String> pilotCounterList = Arrays.asList("C1", "C2");
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(counterRepository.findIdsByCounterCodes(pilotCounterList)).thenReturn(realCounterIds);
        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc("TestJob")).thenReturn(null);
        when(transactionRepository.findByMarketCodeAndCounterNotIn("M1", realCounterIds)).thenReturn(transactionEntities);

        ddpLoyalitySynchUpdateSrvice.loyalitySynchUpdateProcess(conf);

        verify(counterRepository).findIdsByCounterCodes(pilotCounterList);
        verify(loyalitySynchUpdateMetaDataRepository).findTopByJobNameOrderByLastRunTimeDesc("TestJob");
        verify(transactionRepository).findByMarketCodeAndCounterNotIn("M1", realCounterIds);
    }

    @Test
    void testGetRealCounterIds_EmptyInput() {
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            ddpLoyalitySynchUpdateSrvice.getRealCounterIds(Collections.emptyList());
        });

        assertEquals("Counter codes list cannot be null or empty", exception.getMessage());
    }

    @Test
    void testSplitPilotCounterToList_ValidInput() {
        String pilotCounter = "C1, C2, C3";
        List<String> result = ddpLoyalitySynchUpdateSrvice.splitPilotCounterToList(pilotCounter);
        assertEquals(Arrays.asList("C1", "C2", "C3"), result);
    }

    @Test
    void testSplitPilotCounterToList_EmptyInput() {
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            ddpLoyalitySynchUpdateSrvice.splitPilotCounterToList("");
        });

        assertEquals("Input string can not be null or empty", exception.getMessage());
    }

    @Test
    void testFetchNewRecords_LastRunTimeNull() {
        String marketCode = "M1";
        String jobName = "TestJob";
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(transactionRepository.findByMarketCodeAndCounterNotIn(marketCode, realCounterIds)).thenReturn(transactionEntities);

        List<TransactionEntity> result = ddpLoyalitySynchUpdateSrvice.fetchNewRecords(jobName, marketCode, realCounterIds);

        assertEquals(2, result.size());
        verify(transactionRepository).findByMarketCodeAndCounterNotIn(marketCode, realCounterIds);
    }

    @Test
    void testFetchNewRecords_WithLastRunTime() {
        String marketCode = "M1";
        String jobName = "TestJob";
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        ZonedDateTime lastRunTime = ZonedDateTime.now().minusDays(1);
        LoyalitySynchUpdateMetaData metaData = new LoyalitySynchUpdateMetaData();
        metaData.setLastRunTime(lastRunTime);
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc(jobName)).thenReturn(metaData);
        when(transactionRepository.findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(marketCode, realCounterIds, lastRunTime))
                .thenReturn(transactionEntities);

        List<TransactionEntity> result = ddpLoyalitySynchUpdateSrvice.fetchNewRecords(jobName, marketCode, realCounterIds);

        assertEquals(2, result.size());
        verify(transactionRepository).findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(marketCode, realCounterIds, lastRunTime);
    }
} 
==========================================  2

 public Map<PerfTransactionType, List<TransactionEntity>> categorizeTransactions(List<TransactionEntity> newRecords) {
        Map<PerfTransactionType, List<TransactionEntity>> categorizedTransactions = new HashMap<>();

        try {
            if (newRecords == null || newRecords.isEmpty()) {
                log.warn("The newRecords list is null or empty. Returning an empty map.");
                return categorizedTransactions;
            }

            // Initialize the map with empty lists for each transaction type
            for (PerfTransactionType type : PerfTransactionType.values()) {
                categorizedTransactions.put(type, new ArrayList<>());
            }

            // Categorize transactions
            newRecords.forEach(record -> {
                PerfTransactionType transactionType = record.getPerfTransactionType();
                if (transactionType != null) {
                    categorizedTransactions.get(transactionType).add(record);
                } else {
                    log.warn("TransactionEntity with ID [{}] has a null PerfTransactionType.", record.getId());
                }
            });

            log.info("Successfully categorized transactions. Summary: {}"," +
                    categorizedTransactions.entrySet().stream()
                            .map(entry -> entry.getKey() + ": " + entry.getValue().size())
                            .collect(Collectors.joining(", ")));

        } catch (Exception e) {
            log.error("An error occurred while categorizing transactions: {}", e.getMessage(), e);
            throw new RuntimeException("Error categorizing transactions", e);
        }

        return categorizedTransactions;
    }
===============================================3
package com.pg.sparc.market.jp.service.impl;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.time.ZonedDateTime;
import java.util.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import com.pg.sparc.common.ddp.model.DataLoadBaseConfiguation;
import com.pg.sparc.entity.LoyalitySynchUpdateMetaData;
import com.pg.sparc.entity.TransactionEntity;
import com.pg.sparc.entity.types.PerfTransactionType;
import com.pg.sparc.repository.CounterRepository;
import com.pg.sparc.repository.LoyalitySynchUpdateMetaDataRepository;
import com.pg.sparc.repository.TransactionRepository;

@ExtendWith(MockitoExtension.class)
class DDPLoyalitySynchUpdateSrviceImplTest {

    @Mock
    private LoyalitySynchUpdateMetaDataRepository loyalitySynchUpdateMetaDataRepository;

    @Mock
    private TransactionRepository transactionRepository;

    @Mock
    private CounterRepository counterRepository;

    @InjectMocks
    private DDPLoyalitySynchUpdateSrviceImpl ddpLoyalitySynchUpdateSrvice;

    private DataLoadBaseConfiguation conf;

    @BeforeEach
    void setUp() {
        Map<String, String> oldExtensionMap = new HashMap<>();
        oldExtensionMap.put("job-name", "Job_LoyaltySyncUpdate");
        oldExtensionMap.put("pilot-counter", "2000259959,2000259991");
        oldExtensionMap.put("market-code", "hk");
        conf = DataLoadBaseConfiguation.builder()
                .externalParams(oldExtensionMap).build();
    }

    @Test
    void testCategorizeTransactions_ValidInput() {
        List<TransactionEntity> newRecords = Arrays.asList(
                new TransactionEntity("1", PerfTransactionType.ORIGINAL_TRANSACTION),
                new TransactionEntity("2", PerfTransactionType.EDIT_TRANSACTION),
                new TransactionEntity("3", PerfTransactionType.OTHER_TRANSACTION),
                new TransactionEntity("4", PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN)
        );

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertEquals(4, result.size());
        assertEquals(1, result.get(PerfTransactionType.ORIGINAL_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.EDIT_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.OTHER_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN).size());
    }

    @Test
    void testCategorizeTransactions_EmptyInput() {
        List<TransactionEntity> newRecords = Collections.emptyList();

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertTrue(result.values().stream().allMatch(List::isEmpty));
    }

    @Test
    void testCategorizeTransactions_NullInput() {
        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(null);

        assertNotNull(result);
        assertTrue(result.values().stream().allMatch(List::isEmpty));
    }

    @Test
    void testCategorizeTransactions_NullPerfTransactionType() {
        List<TransactionEntity> newRecords = Arrays.asList(
                new TransactionEntity("1", PerfTransactionType.ORIGINAL_TRANSACTION),
                new TransactionEntity("2", null)
        );

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertEquals(1, result.get(PerfTransactionType.ORIGINAL_TRANSACTION).size());
        assertTrue(result.get(PerfTransactionType.EDIT_TRANSACTION).isEmpty());
        assertTrue(result.get(PerfTransactionType.OTHER_TRANSACTION).isEmpty());
        assertTrue(result.get(PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN).isEmpty());
    }

    // Modify the following test to incorporate categorizeTransactions
    @Test
    void testLoyalitySynchUpdateProcess_Success() throws Exception {
        List<String> pilotCounterList = Arrays.asList("2000259959", "2000259991");
        List<String> realCounterIds = Arrays.asList("2000259959", "2000259991");
        LoyalitySynchUpdateMetaData metaData = new LoyalitySynchUpdateMetaData();
        metaData.setLastRunTime(ZonedDateTime.now().minusDays(1));
        List<TransactionEntity> transactionEntities = Arrays.asList(
                new TransactionEntity("1", PerfTransactionType.ORIGINAL_TRANSACTION),
                new TransactionEntity("2", PerfTransactionType.EDIT_TRANSACTION)
        );

        when(counterRepository.findIdsByCounterCodes(pilotCounterList)).thenReturn(realCounterIds);
        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc("Job_LoyaltySyncUpdate")).thenReturn(metaData);
        when(transactionRepository.findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(
                "hk", realCounterIds, metaData.getLastRunTime())).thenReturn(transactionEntities);

        ddpLoyalitySynchUpdateSrvice.loyalitySynchUpdateProcess(conf);

        verify(counterRepository).findIdsByCounterCodes(pilotCounterList);
        verify(loyalitySynchUpdateMetaDataRepository).findTopByJobNameOrderByLastRunTimeDesc("Job_LoyaltySyncUpdate");
        verify(transactionRepository).findByMarketCodeAndCounterNotInAndLastModifiedDateAfter("hk", realCounterIds, metaData.getLastRunTime());
    }
}
================================================================ 4
