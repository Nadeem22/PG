package com.pg.sparc.market.jp.service.impl;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.quartz.JobExecutionException;

import com.pg.sparc.common.ddp.model.DataLoadBaseConfiguation;
import com.pg.sparc.entity.LoyalitySynchUpdateMetaData;
import com.pg.sparc.entity.TransactionEntity;
import com.pg.sparc.repository.CounterRepository;
import com.pg.sparc.repository.LoyalitySynchUpdateMetaDataRepository;
import com.pg.sparc.repository.TransactionRepository;

@ExtendWith(MockitoExtension.class)
class DDPLoyalitySynchUpdateSrviceImplTest {

    @Mock
    private LoyalitySynchUpdateMetaDataRepository loyalitySynchUpdateMetaDataRepository;

    @Mock
    private TransactionRepository transactionRepository;

    @Mock
    private CounterRepository counterRepository;

    @InjectMocks
    private DDPLoyalitySynchUpdateSrviceImpl ddpLoyalitySynchUpdateSrvice;

    private DataLoadBaseConfiguation conf;

    @BeforeEach
    void setUp() {
        conf = new DataLoadBaseConfiguation();
        conf.setExternalParams(Map.of(
            "job-name", "TestJob",
            "pilot-counter", "C1,C2",
            "market-code", "M1"
        ));
    }

    @Test
    void testLoyalitySynchUpdateProcess_Success() throws JobExecutionException {
        List<String> pilotCounterList = Arrays.asList("C1", "C2");
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        LoyalitySynchUpdateMetaData metaData = new LoyalitySynchUpdateMetaData();
        metaData.setLastRunTime(ZonedDateTime.now().minusDays(1));
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(counterRepository.findIdsByCounterCodes(pilotCounterList)).thenReturn(realCounterIds);
        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc("TestJob")).thenReturn(metaData);
        when(transactionRepository.findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(
                "M1", realCounterIds, metaData.getLastRunTime())).thenReturn(transactionEntities);

        ddpLoyalitySynchUpdateSrvice.loyalitySynchUpdateProcess(conf);

        verify(counterRepository).findIdsByCounterCodes(pilotCounterList);
        verify(loyalitySynchUpdateMetaDataRepository).findTopByJobNameOrderByLastRunTimeDesc("TestJob");
        verify(transactionRepository).findByMarketCodeAndCounterNotInAndLastModifiedDateAfter("M1", realCounterIds, metaData.getLastRunTime());
    }

    @Test
    void testLoyalitySynchUpdateProcess_FirstRun() throws JobExecutionException {
        List<String> pilotCounterList = Arrays.asList("C1", "C2");
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(counterRepository.findIdsByCounterCodes(pilotCounterList)).thenReturn(realCounterIds);
        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc("TestJob")).thenReturn(null);
        when(transactionRepository.findByMarketCodeAndCounterNotIn("M1", realCounterIds)).thenReturn(transactionEntities);

        ddpLoyalitySynchUpdateSrvice.loyalitySynchUpdateProcess(conf);

        verify(counterRepository).findIdsByCounterCodes(pilotCounterList);
        verify(loyalitySynchUpdateMetaDataRepository).findTopByJobNameOrderByLastRunTimeDesc("TestJob");
        verify(transactionRepository).findByMarketCodeAndCounterNotIn("M1", realCounterIds);
    }

    @Test
    void testGetRealCounterIds_EmptyInput() {
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            ddpLoyalitySynchUpdateSrvice.getRealCounterIds(Collections.emptyList());
        });

        assertEquals("Counter codes list cannot be null or empty", exception.getMessage());
    }

    @Test
    void testSplitPilotCounterToList_ValidInput() {
        String pilotCounter = "C1, C2, C3";
        List<String> result = ddpLoyalitySynchUpdateSrvice.splitPilotCounterToList(pilotCounter);
        assertEquals(Arrays.asList("C1", "C2", "C3"), result);
    }

    @Test
    void testSplitPilotCounterToList_EmptyInput() {
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            ddpLoyalitySynchUpdateSrvice.splitPilotCounterToList("");
        });

        assertEquals("Input string can not be null or empty", exception.getMessage());
    }

    @Test
    void testFetchNewRecords_LastRunTimeNull() {
        String marketCode = "M1";
        String jobName = "TestJob";
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(transactionRepository.findByMarketCodeAndCounterNotIn(marketCode, realCounterIds)).thenReturn(transactionEntities);

        List<TransactionEntity> result = ddpLoyalitySynchUpdateSrvice.fetchNewRecords(jobName, marketCode, realCounterIds);

        assertEquals(2, result.size());
        verify(transactionRepository).findByMarketCodeAndCounterNotIn(marketCode, realCounterIds);
    }

    @Test
    void testFetchNewRecords_WithLastRunTime() {
        String marketCode = "M1";
        String jobName = "TestJob";
        List<String> realCounterIds = Arrays.asList("ID1", "ID2");
        ZonedDateTime lastRunTime = ZonedDateTime.now().minusDays(1);
        LoyalitySynchUpdateMetaData metaData = new LoyalitySynchUpdateMetaData();
        metaData.setLastRunTime(lastRunTime);
        List<TransactionEntity> transactionEntities = Arrays.asList(new TransactionEntity(), new TransactionEntity());

        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc(jobName)).thenReturn(metaData);
        when(transactionRepository.findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(marketCode, realCounterIds, lastRunTime))
                .thenReturn(transactionEntities);

        List<TransactionEntity> result = ddpLoyalitySynchUpdateSrvice.fetchNewRecords(jobName, marketCode, realCounterIds);

        assertEquals(2, result.size());
        verify(transactionRepository).findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(marketCode, realCounterIds, lastRunTime);
    }
} 
==========================================  2

 public Map<PerfTransactionType, List<TransactionEntity>> categorizeTransactions(List<TransactionEntity> newRecords) {
        Map<PerfTransactionType, List<TransactionEntity>> categorizedTransactions = new HashMap<>();

        try {
            if (newRecords == null || newRecords.isEmpty()) {
                log.warn("The newRecords list is null or empty. Returning an empty map.");
                return categorizedTransactions;
            }

            // Initialize the map with empty lists for each transaction type
            for (PerfTransactionType type : PerfTransactionType.values()) {
                categorizedTransactions.put(type, new ArrayList<>());
            }

            // Categorize transactions
            newRecords.forEach(record -> {
                PerfTransactionType transactionType = record.getPerfTransactionType();
                if (transactionType != null) {
                    categorizedTransactions.get(transactionType).add(record);
                } else {
                    log.warn("TransactionEntity with ID [{}] has a null PerfTransactionType.", record.getId());
                }
            });

            log.info("Successfully categorized transactions. Summary: {}"," +
                    categorizedTransactions.entrySet().stream()
                            .map(entry -> entry.getKey() + ": " + entry.getValue().size())
                            .collect(Collectors.joining(", ")));

        } catch (Exception e) {
            log.error("An error occurred while categorizing transactions: {}", e.getMessage(), e);
            throw new RuntimeException("Error categorizing transactions", e);
        }

        return categorizedTransactions;
    }
===============================================3
package com.pg.sparc.market.jp.service.impl;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.time.ZonedDateTime;
import java.util.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import com.pg.sparc.common.ddp.model.DataLoadBaseConfiguation;
import com.pg.sparc.entity.LoyalitySynchUpdateMetaData;
import com.pg.sparc.entity.TransactionEntity;
import com.pg.sparc.entity.types.PerfTransactionType;
import com.pg.sparc.repository.CounterRepository;
import com.pg.sparc.repository.LoyalitySynchUpdateMetaDataRepository;
import com.pg.sparc.repository.TransactionRepository;

@ExtendWith(MockitoExtension.class)
class DDPLoyalitySynchUpdateSrviceImplTest {

    @Mock
    private LoyalitySynchUpdateMetaDataRepository loyalitySynchUpdateMetaDataRepository;

    @Mock
    private TransactionRepository transactionRepository;

    @Mock
    private CounterRepository counterRepository;

    @InjectMocks
    private DDPLoyalitySynchUpdateSrviceImpl ddpLoyalitySynchUpdateSrvice;

    private DataLoadBaseConfiguation conf;

    @BeforeEach
    void setUp() {
        Map<String, String> oldExtensionMap = new HashMap<>();
        oldExtensionMap.put("job-name", "Job_LoyaltySyncUpdate");
        oldExtensionMap.put("pilot-counter", "2000259959,2000259991");
        oldExtensionMap.put("market-code", "hk");
        conf = DataLoadBaseConfiguation.builder()
                .externalParams(oldExtensionMap).build();
    }

    @Test
    void testCategorizeTransactions_ValidInput() {
        List<TransactionEntity> newRecords = Arrays.asList(
                new TransactionEntity("1", PerfTransactionType.ORIGINAL_TRANSACTION),
                new TransactionEntity("2", PerfTransactionType.EDIT_TRANSACTION),
                new TransactionEntity("3", PerfTransactionType.OTHER_TRANSACTION),
                new TransactionEntity("4", PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN)
        );

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertEquals(4, result.size());
        assertEquals(1, result.get(PerfTransactionType.ORIGINAL_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.EDIT_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.OTHER_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN).size());
    }

    @Test
    void testCategorizeTransactions_EmptyInput() {
        List<TransactionEntity> newRecords = Collections.emptyList();

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertTrue(result.values().stream().allMatch(List::isEmpty));
    }

    @Test
    void testCategorizeTransactions_NullInput() {
        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(null);

        assertNotNull(result);
        assertTrue(result.values().stream().allMatch(List::isEmpty));
    }

    @Test
    void testCategorizeTransactions_NullPerfTransactionType() {
        List<TransactionEntity> newRecords = Arrays.asList(
                new TransactionEntity("1", PerfTransactionType.ORIGINAL_TRANSACTION),
                new TransactionEntity("2", null)
        );

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertEquals(1, result.get(PerfTransactionType.ORIGINAL_TRANSACTION).size());
        assertTrue(result.get(PerfTransactionType.EDIT_TRANSACTION).isEmpty());
        assertTrue(result.get(PerfTransactionType.OTHER_TRANSACTION).isEmpty());
        assertTrue(result.get(PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN).isEmpty());
    }

    // Modify the following test to incorporate categorizeTransactions
    @Test
    void testLoyalitySynchUpdateProcess_Success() throws Exception {
        List<String> pilotCounterList = Arrays.asList("2000259959", "2000259991");
        List<String> realCounterIds = Arrays.asList("2000259959", "2000259991");
        LoyalitySynchUpdateMetaData metaData = new LoyalitySynchUpdateMetaData();
        metaData.setLastRunTime(ZonedDateTime.now().minusDays(1));
        List<TransactionEntity> transactionEntities = Arrays.asList(
                new TransactionEntity("1", PerfTransactionType.ORIGINAL_TRANSACTION),
                new TransactionEntity("2", PerfTransactionType.EDIT_TRANSACTION)
        );

        when(counterRepository.findIdsByCounterCodes(pilotCounterList)).thenReturn(realCounterIds);
        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc("Job_LoyaltySyncUpdate")).thenReturn(metaData);
        when(transactionRepository.findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(
                "hk", realCounterIds, metaData.getLastRunTime())).thenReturn(transactionEntities);

        ddpLoyalitySynchUpdateSrvice.loyalitySynchUpdateProcess(conf);

        verify(counterRepository).findIdsByCounterCodes(pilotCounterList);
        verify(loyalitySynchUpdateMetaDataRepository).findTopByJobNameOrderByLastRunTimeDesc("Job_LoyaltySyncUpdate");
        verify(transactionRepository).findByMarketCodeAndCounterNotInAndLastModifiedDateAfter("hk", realCounterIds, metaData.getLastRunTime());
    }
}
================================================================ 4

package com.pg.sparc.market.jp.service.impl;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.time.ZonedDateTime;
import java.util.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import com.pg.sparc.common.ddp.model.DataLoadBaseConfiguation;
import com.pg.sparc.entity.LoyalitySynchUpdateMetaData;
import com.pg.sparc.entity.TransactionEntity;
import com.pg.sparc.entity.types.PerfTransactionType;
import com.pg.sparc.repository.CounterRepository;
import com.pg.sparc.repository.LoyalitySynchUpdateMetaDataRepository;
import com.pg.sparc.repository.TransactionRepository;

@ExtendWith(MockitoExtension.class)
class DDPLoyalitySynchUpdateSrviceImplTest {

    @Mock
    private LoyalitySynchUpdateMetaDataRepository loyalitySynchUpdateMetaDataRepository;

    @Mock
    private TransactionRepository transactionRepository;

    @Mock
    private CounterRepository counterRepository;

    @InjectMocks
    private DDPLoyalitySynchUpdateSrviceImpl ddpLoyalitySynchUpdateSrvice;

    private DataLoadBaseConfiguation conf;

    @BeforeEach
    void setUp() {
        Map<String, String> oldExtensionMap = new HashMap<>();
        oldExtensionMap.put("job-name", "Job_LoyaltySyncUpdate");
        oldExtensionMap.put("pilot-counter", "2000259959,2000259991");
        oldExtensionMap.put("market-code", "hk");
        conf = DataLoadBaseConfiguation.builder()
                .externalParams(oldExtensionMap).build();
    }

    @Test
    void testCategorizeTransactions_ValidInput() {
        List<TransactionEntity> newRecords = Arrays.asList(
                TransactionEntity.builder().id("1").perfTransactionType(PerfTransactionType.ORIGINAL_TRANSACTION).build(),
                TransactionEntity.builder().id("2").perfTransactionType(PerfTransactionType.EDIT_TRANSACTION).build(),
                TransactionEntity.builder().id("3").perfTransactionType(PerfTransactionType.OTHER_TRANSACTION).build(),
                TransactionEntity.builder().id("4").perfTransactionType(PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN).build()
        );

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertEquals(4, result.size());
        assertEquals(1, result.get(PerfTransactionType.ORIGINAL_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.EDIT_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.OTHER_TRANSACTION).size());
        assertEquals(1, result.get(PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN).size());
    }

    @Test
    void testCategorizeTransactions_EmptyInput() {
        List<TransactionEntity> newRecords = Collections.emptyList();

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertTrue(result.values().stream().allMatch(List::isEmpty));
    }

    @Test
    void testCategorizeTransactions_NullInput() {
        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(null);

        assertNotNull(result);
        assertTrue(result.values().stream().allMatch(List::isEmpty));
    }

    @Test
    void testCategorizeTransactions_NullPerfTransactionType() {
        List<TransactionEntity> newRecords = Arrays.asList(
                TransactionEntity.builder().id("1").perfTransactionType(PerfTransactionType.ORIGINAL_TRANSACTION).build(),
                TransactionEntity.builder().id("2").perfTransactionType(null).build()
        );

        Map<PerfTransactionType, List<TransactionEntity>> result = ddpLoyalitySynchUpdateSrvice.categorizeTransactions(newRecords);

        assertNotNull(result);
        assertEquals(1, result.get(PerfTransactionType.ORIGINAL_TRANSACTION).size());
        assertTrue(result.get(PerfTransactionType.EDIT_TRANSACTION).isEmpty());
        assertTrue(result.get(PerfTransactionType.OTHER_TRANSACTION).isEmpty());
        assertTrue(result.get(PerfTransactionType.NEW_TRANSACTION_FOR_A_RETURN).isEmpty());
    }

    // Modify the following test to incorporate categorizeTransactions
    @Test
    void testLoyalitySynchUpdateProcess_Success() throws Exception {
        List<String> pilotCounterList = Arrays.asList("2000259959", "2000259991");
        List<String> realCounterIds = Arrays.asList("2000259959", "2000259991");
        LoyalitySynchUpdateMetaData metaData = new LoyalitySynchUpdateMetaData();
        metaData.setLastRunTime(ZonedDateTime.now().minusDays(1));
        List<TransactionEntity> transactionEntities = Arrays.asList(
                TransactionEntity.builder().id("1").perfTransactionType(PerfTransactionType.ORIGINAL_TRANSACTION).build(),
                TransactionEntity.builder().id("2").perfTransactionType(PerfTransactionType.EDIT_TRANSACTION).build()
        );

        when(counterRepository.findIdsByCounterCodes(pilotCounterList)).thenReturn(realCounterIds);
        when(loyalitySynchUpdateMetaDataRepository.findTopByJobNameOrderByLastRunTimeDesc("Job_LoyaltySyncUpdate")).thenReturn(metaData);
        when(transactionRepository.findByMarketCodeAndCounterNotInAndLastModifiedDateAfter(
                "hk", realCounterIds, metaData.getLastRunTime())).thenReturn(transactionEntities);

        ddpLoyalitySynchUpdateSrvice.loyalitySynchUpdateProcess(conf);

        verify(counterRepository).findIdsByCounterCodes(pilotCounterList);
        verify(loyalitySynchUpdateMetaDataRepository).findTopByJobNameOrderByLastRunTimeDesc("Job_LoyaltySyncUpdate");
        verify(transactionRepository).findByMarketCodeAndCounterNotInAndLastModifiedDateAfter("hk", realCounterIds, metaData.getLastRunTime());
    }
}

============================ 5

private void processCategorizedTransactions(Map<PerfTransactionType, List<TransactionEntity>> categorizedTransactions, String marketCode) {
    log.info("Starting to process categorized transactions for marketCode: {}", marketCode);

    try {
        if (categorizedTransactions == null || categorizedTransactions.isEmpty()) {
            log.warn("The categorizedTransactions map is null or empty. No processing will be performed.");
            return;
        }

        for (Map.Entry<PerfTransactionType, List<TransactionEntity>> entry : categorizedTransactions.entrySet()) {
            PerfTransactionType transactionType = entry.getKey();
            List<TransactionEntity> transactionEntities = entry.getValue();

            if (transactionEntities == null || transactionEntities.isEmpty()) {
                log.warn("No transactions found for transaction type: {}. Skipping processing.", transactionType);
                continue;
            }

            switch (transactionType) {
                case ORIGINAL:
                    processOriginalTransactions(transactionEntities, marketCode);
                    break;
                case RETURN:
                    processReturnTransactions(transactionEntities, marketCode);
                    break;
                case NEW_PURCHASE:
                    processNewPurchaseTransactions(transactionEntities, marketCode);
                    break;
                case EDIT:
                    processEditTransactions(transactionEntities, marketCode);
                    break;
                default:
                    log.warn("Unhandled transaction type: {}. No processing defined for this type.", transactionType);
            }
        }
    } catch (Exception e) {
        log.error("An error occurred while processing categorized transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing categorized transactions", e);
    }

    log.info("Finished processing categorized transactions for marketCode: {}", marketCode);
}

private void processOriginalTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing ORIGINAL transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    try {
        // Your logic to handle original transactions
        for (TransactionEntity transaction : transactionEntities) {
            // Example logic
            log.debug("Processing transaction ID: {} for ORIGINAL", transaction.getId());
        }
    } catch (Exception e) {
        log.error("Error processing ORIGINAL transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing ORIGINAL transactions", e);
    }
}

private void processReturnTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing RETURN transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    try {
        // Your logic to handle return transactions
        for (TransactionEntity transaction : transactionEntities) {
            log.debug("Processing transaction ID: {} for RETURN", transaction.getId());
        }
    } catch (Exception e) {
        log.error("Error processing RETURN transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing RETURN transactions", e);
    }
}

private void processNewPurchaseTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing NEW_PURCHASE transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    try {
        // Your logic to handle new purchase transactions
        for (TransactionEntity transaction : transactionEntities) {
            log.debug("Processing transaction ID: {} for NEW_PURCHASE", transaction.getId());
        }
    } catch (Exception e) {
        log.error("Error processing NEW_PURCHASE transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing NEW_PURCHASE transactions", e);
    }
}

private void processEditTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing EDIT transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    try {
        // Your logic to handle edit transactions
        for (TransactionEntity transaction : transactionEntities) {
            log.debug("Processing transaction ID: {} for EDIT", transaction.getId());
        }
    } catch (Exception e) {
        log.error("Error processing EDIT transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing EDIT transactions", e);
    }
}
===================================================== 6

@Slf4j
@Service
public class TransactionConversionService {

    private final TransactionEntityModelMapper transactionEntityModelMapper;

    public TransactionConversionService(TransactionEntityModelMapper transactionEntityModelMapper) {
        this.transactionEntityModelMapper = transactionEntityModelMapper;
    }

    /**
     * Converts a list of TransactionEntity to TransactionModel sequentially.
     *
     * @param transactionEntities List of TransactionEntity
     * @return List of TransactionModel
     */
    public List<TransactionModel> convertEntitiesToModels(List<TransactionEntity> transactionEntities) {
        if (transactionEntities == null || transactionEntities.isEmpty()) {
            log.warn("Received empty or null list of TransactionEntity.");
            return Collections.emptyList();
        }

        log.info("Starting conversion of {} TransactionEntity objects to TransactionModel.", transactionEntities.size());

        try {
            return transactionEntities.stream() // Sequential processing
                    .map(entity -> {
                        try {
                            log.debug("Converting TransactionEntity with ID: {}", entity.getId());
                            return transactionEntityModelMapper.entityToModel(entity);
                        } catch (Exception e) {
                            log.error("Error while converting TransactionEntity with ID: {}", entity.getId(), e);
                            throw new RuntimeException("Conversion failed for TransactionEntity ID: " + entity.getId(), e);
                        }
                    })
                    .collect(Collectors.toList());
        } catch (Exception e) {
            log.error("Critical error during conversion of TransactionEntity to TransactionModel.", e);
            throw new RuntimeException("Failed to convert TransactionEntity to TransactionModel.", e);
        } finally {
            log.info("Completed conversion of TransactionEntity to TransactionModel.");
        }
    }
}
====================================================================================== 7

private Map<PerfTransactionType, List<OrderTransactionDto>> processCategorizedTransactions(Map<PerfTransactionType, List<TransactionEntity>> categorizedTransactions, String marketCode) {
    log.info("Starting to process categorized transactions for marketCode: {}", marketCode);

    Map<PerfTransactionType, List<OrderTransactionDto>> result = new HashMap<>();

    try {
        if (categorizedTransactions == null || categorizedTransactions.isEmpty()) {
            log.warn("The categorizedTransactions map is null or empty. No processing will be performed.");
            return Collections.emptyMap();
        }

        for (Map.Entry<PerfTransactionType, List<TransactionEntity>> entry : categorizedTransactions.entrySet()) {
            PerfTransactionType transactionType = entry.getKey();
            List<TransactionEntity> transactionEntities = entry.getValue();

            if (transactionEntities == null || transactionEntities.isEmpty()) {
                log.warn("No transactions found for transaction type: {}. Skipping processing.", transactionType);
                result.put(transactionType, Collections.emptyList());
                continue;
            }

            List<OrderTransactionDto> processedTransactions;
            switch (transactionType) {
                case ORIGINAL_TRANSACTION:
                    processedTransactions = processOriginalTransactions(transactionEntities, marketCode);
                    break;
                case OTHER_TRANSACTION:
                    processedTransactions = processReturnTransactions(transactionEntities, marketCode);
                    break;
                case NEW_TRANSACTION_FOR_A_RETURN:
                    processedTransactions = processNewPurchaseTransactions(transactionEntities, marketCode);
                    break;
                case EDIT_TRANSACTION:
                    processedTransactions = processEditTransactions(transactionEntities, marketCode);
                    break;
                default:
                    log.warn("Unhandled transaction type: {}. No processing defined for this type.", transactionType);
                    processedTransactions = Collections.emptyList();
            }
            result.put(transactionType, processedTransactions);
        }
    } catch (Exception e) {
        log.error("An error occurred while processing categorized transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing categorized transactions", e);
    }

    log.info("Finished processing categorized transactions for marketCode: {}", marketCode);
    return result;
}

private List<OrderTransactionDto> processOriginalTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing ORIGINAL transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    List<TransactionModel> originalTransactionList = convertEntitiesToModels(transactionEntities);
    List<OrderTransactionDto> listOfLoyaltyDto = new ArrayList<>();
    try {
        for (TransactionModel transaction : originalTransactionList) {
            log.debug("Processing transaction ID: {} for ORIGINAL", transaction.getId());
            OrderTransactionDto loyaltyDto = prepareSendCompletedOrderList(transaction, getCounterByTransaction(transaction), marketCode);
            listOfLoyaltyDto.add(loyaltyDto);
        }
        handler.sendMessageCommonService(listOfLoyaltyDto, BusinessType.ORDER_COMPLETED_DATA, marketCode, LANGUAGE_CODE_EN);
    } catch (Exception e) {
        log.error("Error processing ORIGINAL transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing ORIGINAL transactions", e);
    }
    return listOfLoyaltyDto;
}

private List<OrderTransactionDto> processReturnTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing RETURN transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    List<TransactionModel> returnTransactionList = convertEntitiesToModels(transactionEntities);
    List<OrderTransactionDto> listOfLoyaltyDto = new ArrayList<>();
    try {
        for (TransactionModel transaction : returnTransactionList) {
            log.debug("Processing transaction ID: {} for RETURN", transaction.getId());
            OrderTransactionDto loyaltyDto = prepareSendCompletedOrderList(transaction, getCounterByTransaction(transaction), marketCode);
            listOfLoyaltyDto.add(loyaltyDto);
        }
    } catch (Exception e) {
        log.error("Error processing RETURN transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing RETURN transactions", e);
    }
    return listOfLoyaltyDto;
}

private List<OrderTransactionDto> processNewPurchaseTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing NEW_PURCHASE transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    List<TransactionModel> newPurchaseTransactionList = convertEntitiesToModels(transactionEntities);
    List<OrderTransactionDto> listOfLoyaltyDto = new ArrayList<>();
    try {
        for (TransactionModel transaction : newPurchaseTransactionList) {
            log.debug("Processing transaction ID: {} for NEW_PURCHASE", transaction.getId());
            OrderTransactionDto loyaltyDto = prepareSendCompletedOrderList(transaction, getCounterByTransaction(transaction), marketCode);
            listOfLoyaltyDto.add(loyaltyDto);
        }
    } catch (Exception e) {
        log.error("Error processing NEW_PURCHASE transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing NEW_PURCHASE transactions", e);
    }
    return listOfLoyaltyDto;
}

private List<OrderTransactionDto> processEditTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing EDIT transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());
    List<TransactionModel> editTransactionList = convertEntitiesToModels(transactionEntities);
    List<OrderTransactionDto> listOfLoyaltyDto = new ArrayList<>();
    try {
        for (TransactionModel transaction : editTransactionList) {
            log.debug("Processing transaction ID: {} for EDIT", transaction.getId());
            OrderTransactionDto loyaltyDto = prepareSendCompletedOrderList(transaction, getCounterByTransaction(transaction), marketCode);
            listOfLoyaltyDto.add(loyaltyDto);
        }
    } catch (Exception e) {
        log.error("Error processing EDIT transactions: {}", e.getMessage(), e);
        throw new RuntimeException("Error processing EDIT transactions", e);
    }
    return listOfLoyaltyDto;
}
====================================================================================== 8

public OrderTransactionDto prepareSendCompletedOrderList(TransactionModel transaction, CounterEntity counterEntity, String marketCode) {
    log.info("Starting to prepare OrderTransactionDto for transaction ID: {} and marketCode: {}", transaction.getId(), marketCode);

    OrderTransactionDto loyaltyDto;
    try {
        // Convert transaction and counter entity to DTO
        loyaltyDto = completedMapper.toDto(transaction, counterEntity, marketCode);
        log.debug("Successfully mapped transaction ID: {} to OrderTransactionDto", transaction.getId());

        // Extract campaign IDs from the transaction
        List<String> campaignIds = transaction.getTransactionCampaigns().stream()
            .map(TransactionCampaignModel::getCampaignId)
            .collect(Collectors.toList());
        log.debug("Extracted campaign IDs: {} for transaction ID: {}", campaignIds, transaction.getId());

        // Fetch campaign details
        List<CampaignBasicDetailModel> campaignDetails = campaignService.getCampaignDetails(campaignIds, marketCode, LanguageCode.EN);
        log.debug("Fetched campaign details for transaction ID: {}", transaction.getId());

        // Populate campaign names and codes in the DTO
        List<CampaignDto> campaignDtoList = loyaltyDto.getCampaignList();
        if (campaignDtoList != null && !campaignDtoList.isEmpty()) {
            Map<String, CampaignBasicDetailModel> campaignDetailMap = campaignDetails.stream()
                .collect(Collectors.toMap(CampaignBasicDetailModel::getCampaignId, model -> model));

            campaignDtoList.forEach(campaignDto -> {
                CampaignBasicDetailModel detailModel = campaignDetailMap.get(campaignDto.getCampaignId());
                if (detailModel != null) {
                    campaignDto.setCampaignName(detailModel.getCampaignName());
                    campaignDto.setCampaignCode(detailModel.getCampaignCode());
                    log.debug("Updated campaign DTO with ID: {} with name: {} and code: {}", 
                              campaignDto.getCampaignId(), detailModel.getCampaignName(), detailModel.getCampaignCode());
                } else {
                    log.warn("No details found for campaign ID: {} in transaction ID: {}", campaignDto.getCampaignId(), transaction.getId());
                }
            });
        } else {
            log.warn("No campaign DTOs found for transaction ID: {}", transaction.getId());
        }

        // Set additional fields in the DTO
        loyaltyDto.setPurchaseUpdateDate(ZonedDateTime.now()
            .withZoneSameInstant(ZoneId.systemDefault())
            .format(TimeUtil.PURCHASE_UPDATE_DATE_FORMAT_FOR_LOYALTY));
        loyaltyDto.setEventType(BusinessType.ORDER_COMPLETED_DATA.getCode());

        log.info("Successfully prepared OrderTransactionDto for transaction ID: {}", transaction.getId());
    } catch (Exception e) {
        log.error("Error while preparing OrderTransactionDto for transaction ID: {}: {}", transaction.getId(), e.getMessage(), e);
        throw new RuntimeException("Error preparing OrderTransactionDto for transaction ID: " + transaction.getId(), e);
    }

    return loyaltyDto;
}
====================================================================================  10

OrderTransactionDto sendRefundedOrder(TransactionModel returnTransaction, CounterEntity counterEntity, String marketCode) {
    log.info("Starting to process refunded order for return transaction ID: {} and marketCode: {}", returnTransaction.getId(), marketCode);
    OrderTransactionDto orderLoyalty = null;

    try {
        // Get the original transaction
        TransactionModel mainTransaction = getOriginalTransaction(returnTransaction);
        if (Objects.isNull(mainTransaction)) {
            log.warn("Original transaction not found for return transaction ID: {}", returnTransaction.getId());
            return null;
        }

        // Get consumer details
        ConsumerDetailDto consumer = amProxyService.getUserByConsumerId(returnTransaction.getMemberId()).orElse(null);
        if (!isOneStatusConsumer(returnTransaction.getMemberId(), consumer)) {
            log.warn("Consumer does not have valid ONE status for return transaction ID: {}", returnTransaction.getId());
            return null;
        }

        // Get the purchase transaction
        TransactionModel purchaseTransaction = getPurchaseTransaction(returnTransaction);
        boolean isSendToLoyalty = getResultIsSendToLoyalty(consumer);

        // Map to OrderTransactionDto
        orderLoyalty = refundedMapper.toDto(
            returnTransaction, purchaseTransaction, mainTransaction, counterEntity, false, isSendToLoyalty, marketCode);

        // Populate campaign details
        populateCampaignDetails(returnTransaction, orderLoyalty, marketCode);

    } catch (Exception e) {
        log.error("Error while processing refunded order for return transaction ID: {}: {}", returnTransaction.getId(), e.getMessage(), e);
        throw new RuntimeException("Error processing refunded order for return transaction ID: " + returnTransaction.getId(), e);
    }

    log.info("Successfully processed refunded order for return transaction ID: {}", returnTransaction.getId());
    return orderLoyalty;
}

private void populateCampaignDetails(TransactionModel returnTransaction, OrderTransactionDto orderLoyalty, String marketCode) {
    try {
        List<String> campaignIds = returnTransaction.getTransactionCampaigns().stream()
            .map(TransactionCampaignModel::getCampaignId)
            .collect(Collectors.toList());
        List<CampaignBasicDetailModel> campaignDetails = campaignService.getCampaignDetails(campaignIds, marketCode, LanguageCode.EN);

        List<CampaignDto> campaignDtoList = orderLoyalty.getCampaignList();
        if (campaignDtoList != null && !campaignDtoList.isEmpty()) {
            Map<String, CampaignBasicDetailModel> campaignDetailMap = campaignDetails.stream()
                .collect(Collectors.toMap(CampaignBasicDetailModel::getCampaignId, model -> model));

            campaignDtoList.forEach(campaignDto -> {
                CampaignBasicDetailModel detailModel = campaignDetailMap.get(campaignDto.getCampaignId());
                if (detailModel != null) {
                    campaignDto.setCampaignName(detailModel.getCampaignName());
                    campaignDto.setCampaignCode(detailModel.getCampaignCode());
                    log.debug("Updated campaign DTO with ID: {} with name: {} and code: {}", 
                              campaignDto.getCampaignId(), detailModel.getCampaignName(), detailModel.getCampaignCode());
                } else {
                    log.warn("No details found for campaign ID: {} in return transaction ID: {}", campaignDto.getCampaignId(), returnTransaction.getId());
                }
            });
        } else {
            log.warn("No campaign DTOs found for return transaction ID: {}", returnTransaction.getId());
        }
    } catch (Exception e) {
        log.error("Error populating campaign details for return transaction ID: {}: {}", returnTransaction.getId(), e.getMessage(), e);
        throw new RuntimeException("Error populating campaign details for return transaction ID: " + returnTransaction.getId(), e);
    }
}

TransactionModel getOriginalTransaction(TransactionModel returnTransaction) {
    log.debug("Fetching original transaction for return transaction ID: {}", returnTransaction.getId());
    try {
        String originalTransactionId = returnTransaction.getProperties()
            .get(TransactionPropertyItemKeyType.EXT_ORIGINAL_TRANSACTION_ID.getValue());
        if (Strings.isNotBlank(originalTransactionId)) {
            return transactionRepository.findById(originalTransactionId)
                .map(transactionMapper::entityToModel)
                .orElse(null);
        }
    } catch (Exception e) {
        log.error("Error fetching original transaction for return transaction ID: {}: {}", returnTransaction.getId(), e.getMessage(), e);
    }
    return null;
}

private boolean isOneStatusConsumer(String memberId, final ConsumerDetailDto consumer) {
    try {
        if (consumer == null || consumer.getBasic() == null || 
            !StringUtils.equals(consumer.getBasic().getConsumerOneIdStatus(), ONE)) {
            log.warn(MSG_CONSUMER_ONE_ID_STATUS, memberId);
            return false;
        }
    } catch (Exception e) {
        log.error("Error validating ONE status for member ID: {}: {}", memberId, e.getMessage(), e);
        return false;
    }
    return true;
}

private TransactionModel getPurchaseTransaction(TransactionModel returnTransaction) {
    log.debug("Fetching purchase transaction for return transaction ID: {}", returnTransaction.getId());
    try {
        String purchaseTransactionId = returnTransaction.getProperties()
            .get(TransactionPropertyItemKeyType.EXT_PURCHASE_TRANSACTION_ID.getValue());

        if (Strings.isNotBlank(purchaseTransactionId)) {
            return transactionRepository.findById(purchaseTransactionId)
                .map(transactionMapper::entityToModel)
                .orElse(null);
        }
    } catch (Exception e) {
        log.error("Error fetching purchase transaction for return transaction ID: {}: {}", returnTransaction.getId(), e.getMessage(), e);
    }
    return null;
}

boolean getResultIsSendToLoyalty(ConsumerDetailDto vipDetail) {
    log.debug("Determining if the transaction should be sent to loyalty for consumer ID: {}", 
              vipDetail != null ? vipDetail.getBasic().getConsumerId() : "null");
    boolean isSendToLoyalty = true;
    try {
        if (vipDetail == null || vipDetail.getBinds() == null || vipDetail.getSubscription() == null ||
            vipDetail.getBinds().isEmpty() ||
            vipDetail.getBinds().stream().noneMatch(bind -> BIND_TYPE_VALUE.equalsIgnoreCase(bind.getBindType())) ||
            !YES_VALUE.equalsIgnoreCase(vipDetail.getBinds().get(0).getAttentionStatus()) ||
            !YES_VALUE.equalsIgnoreCase(vipDetail.getSubscription().getSubscriptionStatus()) ||
            !CODE_VALUE.equalsIgnoreCase(vipDetail.getSubscription().getSubscriptionCode())) {
            isSendToLoyalty = false;
        }
    } catch (Exception e) {
        log.error("Error determining loyalty eligibility for consumer ID: {}: {}", 
                  vipDetail != null ? vipDetail.getBasic().getConsumerId() : "null", e.getMessage(), e);
        isSendToLoyalty = false;
    }
    return isSendToLoyalty;
}
====================================================================== 11
OrderTransactionDto sendEditedOrder(TransactionModel editedTransaction, CounterEntity counterEntity, String marketCode) {
    log.info("Starting to process edited order for transaction ID: {} and marketCode: {}", editedTransaction.getId(), marketCode);
    OrderTransactionDto loyaltyDto;

    try {
        // Map the edited transaction and counter entity to DTO
        loyaltyDto = completedMapper.toDto(editedTransaction, counterEntity, marketCode);
        log.debug("Successfully mapped transaction ID: {} to OrderTransactionDto", editedTransaction.getId());

        // Extract campaign IDs
        List<String> campaignIds = editedTransaction.getTransactionCampaigns().stream()
            .map(TransactionCampaignModel::getCampaignId)
            .collect(Collectors.toList());
        log.debug("Extracted campaign IDs: {} for transaction ID: {}", campaignIds, editedTransaction.getId());

        // Fetch campaign details
        List<CampaignBasicDetailModel> campaignDetails = campaignService.getCampaignDetails(campaignIds, marketCode, LanguageCode.EN);
        log.debug("Fetched campaign details for transaction ID: {}", editedTransaction.getId());

        // Populate campaign names and codes in the DTO
        List<CampaignDto> campaignDtoList = loyaltyDto.getCampaignList();
        if (campaignDtoList != null && !campaignDtoList.isEmpty()) {
            Map<String, CampaignBasicDetailModel> campaignDetailMap = campaignDetails.stream()
                .collect(Collectors.toMap(CampaignBasicDetailModel::getCampaignId, model -> model));

            campaignDtoList.forEach(campaignDto -> {
                CampaignBasicDetailModel detailModel = campaignDetailMap.get(campaignDto.getCampaignId());
                if (detailModel != null) {
                    campaignDto.setCampaignName(detailModel.getCampaignName());
                    campaignDto.setCampaignCode(detailModel.getCampaignCode());
                    log.debug("Updated campaign DTO with ID: {} with name: {} and code: {}", 
                              campaignDto.getCampaignId(), detailModel.getCampaignName(), detailModel.getCampaignCode());
                } else {
                    log.warn("No details found for campaign ID: {} in transaction ID: {}", campaignDto.getCampaignId(), editedTransaction.getId());
                }
            });
        } else {
            log.warn("No campaign DTOs found for transaction ID: {}", editedTransaction.getId());
        }

        // Set additional fields in the DTO
        loyaltyDto.setPurchaseUpdateDate(ZonedDateTime.now()
            .withZoneSameInstant(ZoneId.systemDefault())
            .format(TimeUtil.PURCHASE_UPDATE_DATE_FORMAT_FOR_LOYALTY));
        loyaltyDto.setEventType(BusinessType.ORDER_EDIT_COMPLETED_DATA.getCode());

        log.info("Successfully processed edited order for transaction ID: {}", editedTransaction.getId());
    } catch (Exception e) {
        log.error("Error while processing edited order for transaction ID: {}: {}", editedTransaction.getId(), e.getMessage(), e);
        throw new RuntimeException("Error processing edited order for transaction ID: " + editedTransaction.getId(), e);
    }
================================================================ 12
List<OrderTransactionDto> processOriginalTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing ORIGINAL transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());

    // Validate input
    if (transactionEntities == null || transactionEntities.isEmpty()) {
        log.warn("Received null or empty transactionEntities list for marketCode: {}", marketCode);
        return Collections.emptyList();
    }

    List<TransactionModel> originalTransactionList = convertEntitiesToModels(transactionEntities);
    if (originalTransactionList == null || originalTransactionList.isEmpty()) {
        log.warn("Converted transactionEntities to an empty or null originalTransactionList for marketCode: {}", marketCode);
        return Collections.emptyList();
    }

    List<OrderTransactionDto> listOfLoyalityDto = new ArrayList<>();

    try {
        for (TransactionModel transaction : originalTransactionList) {
            try {
                log.debug("Processing transaction ID: {} for ORIGINAL", transaction.getId());
                OrderTransactionDto loyalityDto = prepareSendCompletedOrderList(transaction, getCounterByTransaction(transaction), marketCode);

                if (loyalityDto != null) {
                    listOfLoyalityDto.add(loyalityDto);
                } else {
                    log.warn("Failed to prepare OrderTransactionDto for transaction ID: {}", transaction.getId());
                }
            } catch (Exception ex) {
                log.error("Error processing transaction ID: {} for ORIGINAL: {}", transaction.getId(), ex.getMessage(), ex);
            }
        }

        log.info("Successfully processed {} ORIGINAL transactions for marketCode: {}", listOfLoyalityDto.size(), marketCode);
    } catch (Exception e) {
        log.error("Critical error while processing ORIGINAL transactions for marketCode: {}: {}", marketCode, e.getMessage(), e);
        throw new RuntimeException("Error processing ORIGINAL transactions for marketCode: " + marketCode, e);
    }

    return listOfLoyalityDto;
}

    return loyaltyDto;
}
==================================================================== 13
List<OrderTransactionDto> processReturnTransactions(List<TransactionEntity> transactionEntities, String marketCode) {
    log.info("Processing RETURN transactions. MarketCode: {}, Count: {}", marketCode, transactionEntities.size());

    // Validate input
    if (transactionEntities == null || transactionEntities.isEmpty()) {
        log.warn("Received null or empty transactionEntities list for RETURN transactions in marketCode: {}", marketCode);
        return Collections.emptyList();
    }

    List<TransactionModel> returnTransactionList = convertEntitiesToModels(transactionEntities);
    if (returnTransactionList == null || returnTransactionList.isEmpty()) {
        log.warn("Converted transactionEntities to an empty or null returnTransactionList for marketCode: {}", marketCode);
        return Collections.emptyList();
    }

    List<OrderTransactionDto> listOfLoyalityDto = new ArrayList<>();

    try {
        for (TransactionModel transaction : returnTransactionList) {
            try {
                log.debug("Processing transaction ID: {} for RETURN", transaction.getId());
                OrderTransactionDto loyalityDto = sendRefundedOrder(transaction, getCounterByTransaction(transaction), marketCode);

                if (loyalityDto != null) {
                    listOfLoyalityDto.add(loyalityDto);
                } else {
                    log.warn("Failed to prepare OrderTransactionDto for transaction ID: {}", transaction.getId());
                }
            } catch (Exception ex) {
                log.error("Error processing transaction ID: {} for RETURN: {}", transaction.getId(), ex.getMessage(), ex);
            }
        }

        log.info("Successfully processed {} RETURN transactions for marketCode: {}", listOfLoyalityDto.size(), marketCode);
    } catch (Exception e) {
        log.error("Critical error while processing RETURN transactions for marketCode: {}: {}", marketCode, e.getMessage(), e);
        throw new RuntimeException("Error processing RETURN transactions for marketCode: " + marketCode, e);
    }

    return listOfLoyalityDto;
}

